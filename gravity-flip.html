<!DOCTYPE html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P1VFNJ21V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-P1VFNJ21V0');</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9556113318001178" crossorigin="anonymous"></script>
<meta charset="UTF-8">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü™®</text></svg>">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravity Flip ‚Äì GameCave</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Nunito:wght@400;700;800&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#060310;}
body{display:flex;flex-direction:column;font-family:'Nunito',sans-serif;}
.topbar{flex-shrink:0;background:rgba(6,3,16,0.96);border-bottom:2px solid #1e1038;padding:0.6rem 1.2rem;display:flex;align-items:center;justify-content:space-between;z-index:10;}
.logo{font-family:'Cinzel',serif;font-size:1.1rem;font-weight:900;color:#e8a020;text-decoration:none;letter-spacing:0.08em;}
.logo span{color:#ffcc55;}
.back{color:#9a8870;text-decoration:none;font-size:0.75rem;font-weight:700;text-transform:uppercase;letter-spacing:0.1em;padding:0.35rem 0.9rem;border:1px solid #2a1850;border-radius:3px;transition:all .15s;}
.back:hover{color:#ffcc55;border-color:#9b5de5;}
canvas{display:block;flex:1;touch-action:none;cursor:pointer;}
</style>
</head>
<body>
<!-- LOADING SCREEN -->
<div id="loadingScreen" style="position:fixed;inset:0;z-index:9999;background:#060310;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:opacity 0.5s ease;">
  <div style="font-family:'Cinzel',serif;font-size:2.5rem;font-weight:900;color:#9b5de5;text-shadow:0 0 20px rgba(155,93,229,0.6);letter-spacing:0.1em;">ü™® GAMECAVE</div>
  <div style="margin-top:1rem;font-family:'Nunito',sans-serif;font-size:1rem;color:#9a8870;letter-spacing:0.15em;text-transform:uppercase;">Loading‚Ä¶</div>
  <div style="margin-top:1.5rem;width:120px;height:4px;background:#1e1038;border-radius:2px;overflow:hidden;">
    <div id="loadBar" style="height:100%;background:#9b5de5;width:0%;transition:width 0.7s ease;border-radius:2px;"></div>
  </div>
</div>
<script>
  document.getElementById('loadBar').style.width = '100%';
  window.addEventListener('load', () => {
    setTimeout(() => {
      const ls = document.getElementById('loadingScreen');
      ls.style.opacity = '0';
      setTimeout(() => ls.style.display = 'none', 500);
    }, 400);
  });
</script>
<div class="topbar">
  <a class="logo" href="index.html">ü™® GAME<span>CAVE</span></a>
  <a class="back" href="index.html">‚Üê Back</a>
</div>
<canvas id="c"></canvas>
<script>
'use strict';
// ‚îÄ‚îÄ SOUND ENGINE ‚îÄ‚îÄ
const sfx = (() => {
  let ctx;
  function ensure() { if (!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)(); return ctx; }
  function play(name) {
    try {
      const c = ensure();
      const g = c.createGain();
      g.connect(c.destination);
      const o = c.createOscillator();
      o.connect(g);
      const t = c.currentTime;
      if (name==='start') {
        o.frequency.setValueAtTime(440,t); o.frequency.linearRampToValueAtTime(880,t+0.15);
        g.gain.setValueAtTime(0.25,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2);
      } else if (name==='score'||name==='point') {
        o.frequency.setValueAtTime(660,t); o.frequency.linearRampToValueAtTime(880,t+0.08);
        g.gain.setValueAtTime(0.2,t); g.gain.linearRampToValueAtTime(0,t+0.12); o.start(t); o.stop(t+0.12);
      } else if (name==='die'||name==='over') {
        o.type='sawtooth'; o.frequency.setValueAtTime(330,t); o.frequency.linearRampToValueAtTime(110,t+0.3);
        g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.35); o.start(t); o.stop(t+0.35);
      } else if (name==='jump'||name==='click') {
        o.frequency.setValueAtTime(300,t); o.frequency.linearRampToValueAtTime(600,t+0.1);
        g.gain.setValueAtTime(0.18,t); g.gain.linearRampToValueAtTime(0,t+0.12); o.start(t); o.stop(t+0.12);
      } else if (name==='nearMiss') {
        // whoosh for a close call
        o.type='sine'; o.frequency.setValueAtTime(800,t); o.frequency.linearRampToValueAtTime(200,t+0.15);
        g.gain.setValueAtTime(0.08,t); g.gain.linearRampToValueAtTime(0,t+0.18); o.start(t); o.stop(t+0.18);
      } else if (name==='levelup') {
        // ascending fanfare on level up
        [392,494,587,784].forEach((f,i)=>{ const o2=c.createOscillator(); o2.connect(g); o2.type='triangle'; o2.frequency.value=f; o2.start(t+i*0.09); o2.stop(t+i*0.09+0.12); });
        g.gain.setValueAtTime(0.2,t); g.gain.linearRampToValueAtTime(0,t+0.48); o.disconnect();
      } else if (name==='shield') {
        // shield pickup
        o.type='triangle'; o.frequency.setValueAtTime(600,t); o.frequency.linearRampToValueAtTime(900,t+0.08); o.frequency.linearRampToValueAtTime(700,t+0.15);
        g.gain.setValueAtTime(0.2,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2);
      } else if (name==='shieldHit') {
        // shield absorbs hit
        o.type='square'; o.frequency.setValueAtTime(440,t); o.frequency.linearRampToValueAtTime(200,t+0.15);
        g.gain.setValueAtTime(0.25,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2);
      } else if (name==='gemChain') {
        // collecting multiple gems in a row
        [784,880,988].forEach((f,i)=>{ const o2=c.createOscillator(); o2.connect(g); o2.type='sine'; o2.frequency.value=f; o2.start(t+i*0.06); o2.stop(t+i*0.06+0.09); });
        g.gain.setValueAtTime(0.2,t); g.gain.linearRampToValueAtTime(0,t+0.28); o.disconnect();
      }
    } catch(e) {}
  }
  return { play };
})();

// ‚îÄ‚îÄ PLAYER COLOR ‚îÄ‚îÄ
const PLAYER_COLORS = ['#9b5de5','#3db8a0','#e8a020','#ff4444','#4488ff'];
const PLAYER_COLORS_RGBA = ['rgba(155,93,229,0.45)','rgba(61,184,160,0.45)','rgba(232,160,32,0.45)','rgba(255,68,68,0.45)','rgba(68,136,255,0.45)'];
const PLAYER_COLORS_RGBA_DIM = ['rgba(155,93,229,0.08)','rgba(61,184,160,0.08)','rgba(232,160,32,0.08)','rgba(255,68,68,0.08)','rgba(68,136,255,0.08)'];
let playerColor = PLAYER_COLORS[0];
let playerColorRGBA = PLAYER_COLORS_RGBA[0];
let playerColorRGBADim = PLAYER_COLORS_RGBA_DIM[0];
let playerColorIdx = 0;
const C = document.getElementById('c');
const X = C.getContext('2d');
let W, H;

function resize() {
  const rect = C.getBoundingClientRect();
  W = C.width  = window.innerWidth;
  H = C.height = window.innerHeight - rect.top;
}
resize();
window.addEventListener('resize', () => { resize(); if(phase!=='play') drawMenu(); });

/* ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ */
const PX   = 100;   // player fixed x
const PSZ  = 22;    // player half-size (square)
const WALL_W = 22;  // wall thickness
const GRAV = 0.40;
const FLIP_IMPULSE = 7.8;

/* ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ */
let py, pvy, flipped;
let walls, gems, shields, trail, parts;
let score, hi=parseInt(localStorage.getItem('gravityflip_hi'))||0, level, speed;
let tick, spawnTimer, lastLevel;
let running=false, phase='menu', raf=0;
let shake=0, invTimer=0, lastFlipY=0;
let deathParts=[];
let hasShield=false, gemStreak=0;

function resetGame() {
  py = H/2 - PSZ;
  pvy = 0;
  flipped = false;
  walls = [];
  gems = [];
  shields = [];
  trail = [];
  parts = [];
  deathParts = [];
  score = 0;
  level = 1;
  lastLevel = 1;
  speed = 3.0;
  tick = 0;
  spawnTimer = 0;
  shake = 0;
  invTimer = 0;
  hasShield = false;
  gemStreak = 0;
  // Pre-fill walls so screen isn't empty at start
  let wx = W + 60;
  for(let i = 0; i < 12; i++) {
    wx += wallSpacing();
    pushWall(wx);
  }
}

/* ‚îÄ‚îÄ‚îÄ WALL HELPERS ‚îÄ‚îÄ‚îÄ */
function wallSpacing() {
  // First few gaps are very generous, tightens with level
  return 200 + Math.random()*100 - level*5;
}

function gapSize() {
  // starts at 160px, minimum 90px at high levels
  return Math.max(90, 165 - level*6);
}

function pushWall(wx) {
  const gap = gapSize();
  const topMax = H - gap - 40;
  const topH = 40 + Math.random() * topMax;
  walls.push({ x: wx, topH, botH: H - topH - gap, gap, w: WALL_W, scored: false, nearMissed: false });
  // crystal chance
  if(Math.random() < 0.5) {
    gems.push({
      x: wx + WALL_W/2,
      y: topH + gap/2 + (Math.random()-0.5)*gap*0.3,
      r: 8, alive: true, pulse: Math.random()*Math.PI*2
    });
  }
  // Shield pickup chance: 15%, only if player doesn't already have one
  if(!hasShield && Math.random() < 0.15) {
    shields.push({
      x: wx + WALL_W/2 + 60,
      y: topH + gap/2,
      r: 10, alive: true, pulse: Math.random()*Math.PI*2
    });
  }
}

/* ‚îÄ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ‚îÄ */
function burst(x, y, col, n, spd) {
  spd = spd || 5;
  for(let i=0;i<n;i++) {
    const a=Math.random()*Math.PI*2, s=spd*(0.3+Math.random());
    parts.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:1.5+Math.random()*3,col,a:1,d:0.025+Math.random()*0.02});
  }
}

function popTxt(x,y,txt,col,big) {
  parts.push({x,y,vx:(Math.random()-0.5)*0.8,vy:-2.8,r:0,col,a:1,d:0.022,pop:true,txt,sz:big?22:16});
}

/* ‚îÄ‚îÄ‚îÄ FLIP ‚îÄ‚îÄ‚îÄ */
function doFlip() {
  if(phase !== 'play') { startGame(); return; }
  sfx.play('jump');
  flipped = !flipped;
  pvy = flipped ? FLIP_IMPULSE : -FLIP_IMPULSE;
  lastFlipY = py;
  // visual burst at player center
  const col = playerColor;
  burst(PX+PSZ, py+PSZ, col, 8, 4);
}

/* ‚îÄ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ‚îÄ */
function update() {
  tick++;

  // Level and speed
  level = 1 + Math.floor(score / 12);
  speed = 3.0 + (level-1) * 0.32;

  // Level up fanfare
  if(level > lastLevel) {
    lastLevel = level;
    sfx.play('levelup');
    popTxt(PX+PSZ, py, 'LVL '+level+' ‚¨Ü', '#ffcc55', true);
  }

  // Physics
  const gDir = flipped ? -1 : 1;
  pvy += GRAV * gDir;
  // clamp velocity so it doesn't get too extreme
  pvy = Math.max(-12, Math.min(12, pvy));
  py += pvy;

  // Trail
  trail.push({x: PX+PSZ, y: py+PSZ});
  if(trail.length > 20) trail.shift();

  // Scroll walls + gems + shields
  walls.forEach(w => w.x -= speed);
  gems.forEach(g => g.x -= speed);
  shields.forEach(s => s.x -= speed);

  // Cull
  walls   = walls.filter(w => w.x > -WALL_W-10);
  gems    = gems.filter(g  => g.x > -20);
  shields = shields.filter(s => s.x > -20);

  // Spawn
  const lastX = walls.length ? walls[walls.length-1].x : W;
  if(lastX < W + 80) pushWall(lastX + wallSpacing());

  // Score + near-miss detection
  walls.forEach(w => {
    if(!w.scored && w.x + w.w < PX) {
      w.scored = true;
      score++;
      sfx.play('score');
      if(score > hi) { hi = score; localStorage.setItem('gravityflip_hi', hi); }
    }
    // Near-miss: wall just passed, player was within gap but close to an edge
    if(!w.nearMissed && w.x + w.w < PX && w.x + w.w > PX - speed * 2) {
      const playerCy = py + PSZ;
      const gapTop = w.topH, gapBot = H - w.botH;
      const NEAR_MISS_MARGIN = 28; // px from gap edge counts as a near-miss
      if(playerCy >= gapTop && playerCy <= gapBot &&
         (playerCy < gapTop + NEAR_MISS_MARGIN || playerCy > gapBot - NEAR_MISS_MARGIN)) {
        w.nearMissed = true;
        sfx.play('nearMiss');
        popTxt(PX+PSZ, py, 'CLOSE! üò¨', '#ff9900');
      }
    }
  });

  // Gem collection
  gems.forEach(g => {
    if(!g.alive) return;
    g.pulse += 0.08;
    const dist = Math.hypot(PX+PSZ - g.x, py+PSZ - g.y);
    if(dist < g.r + PSZ*0.8) {
      g.alive = false;
      score += 3;
      gemStreak++;
      if(gemStreak >= 3) {
        sfx.play('gemChain');
        popTxt(g.x, g.y-20, 'üíé CHAIN x'+gemStreak+'!', '#3db8a0', true);
      } else {
        sfx.play('score');
        popTxt(g.x, g.y-16, '+3 üíé', '#3db8a0');
      }
      if(score > hi) { hi = score; localStorage.setItem('gravityflip_hi', hi); }
      burst(g.x, g.y, '#3db8a0', 14, 5);
    }
  });

  // Shield collection
  shields.forEach(s => {
    if(!s.alive) return;
    s.pulse += 0.08;
    const dist = Math.hypot(PX+PSZ - s.x, py+PSZ - s.y);
    if(dist < s.r + PSZ*0.8) {
      s.alive = false;
      hasShield = true;
      sfx.play('shield');
      burst(s.x, s.y, '#4488ff', 16, 5);
      popTxt(s.x, s.y-16, 'üõ° SHIELD!', '#4488ff', true);
    }
  });

  // Particles
  parts.forEach(p => {
    if(!p.pop) { p.x+=p.vx; p.y+=p.vy; p.vx*=0.90; p.vy+=0.08; }
    else        { p.x+=p.vx; p.y+=p.vy; }
    p.a -= p.d;
  });
  parts = parts.filter(p => p.a > 0);

  // Screen shake decay
  shake = Math.max(0, shake-1.5);

  // Invincibility frames
  if(invTimer > 0) { invTimer--; return; }

  // ‚îÄ‚îÄ COLLISION ‚îÄ‚îÄ
  // Top/bottom walls
  if(py < 0 || py + PSZ*2 > H) { die(); return; }

  // Cave walls
  const px1 = PX + 3, px2 = PX + PSZ*2 - 3;
  const py1 = py + 3, py2 = py + PSZ*2 - 3;
  for(const w of walls) {
    if(px2 > w.x && px1 < w.x + w.w) {
      if(py1 < w.topH || py2 > H - w.botH) { die(); return; }
    }
  }
}

function die() {
  if(hasShield) {
    // Shield absorbs the hit
    hasShield = false;
    shake = 10;
    invTimer = 60; // ~1s of post-shield invincibility at 60 FPS
    sfx.play('shieldHit');
    burst(PX+PSZ, py+PSZ, '#4488ff', 20, 7);
    popTxt(PX+PSZ, py, 'üõ° SAVED!', '#4488ff', true);
    return;
  }
  shake = 18;
  sfx.play('die');
  burst(PX+PSZ, py+PSZ, '#e8a020', 30, 9);
  burst(PX+PSZ, py+PSZ, '#ff6a00', 18, 6);
  burst(PX+PSZ, py+PSZ, '#fff', 8, 4);
  running = false;
  gtag('event','game_over',{game:'Gravity Flip',score});
  setTimeout(() => { phase='over'; drawGameOver(); }, 500);
}

/* ‚îÄ‚îÄ‚îÄ DRAW GAME ‚îÄ‚îÄ‚îÄ */
function drawGame() {
  X.save();
  if(shake > 0) {
    const s = shake * 0.6;
    X.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
  }

  // Background
  const bg = X.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,  '#04020c');
  bg.addColorStop(0.5,'#080418');
  bg.addColorStop(1,  '#04020c');
  X.fillStyle = bg; X.fillRect(0,0,W,H);

  // Scrolling background streaks (depth feeling)
  X.strokeStyle = 'rgba(155,93,229,0.04)'; X.lineWidth = 1;
  for(let i = 0; i < 10; i++) {
    const rx = ((i*85 + tick*speed*0.15) % (W+85)) - 85;
    X.beginPath(); X.moveTo(rx, 0); X.lineTo(rx+35, H); X.stroke();
  }

  // Ambient glow at player
  const ag = X.createRadialGradient(PX+PSZ, py+PSZ, 0, PX+PSZ, py+PSZ, 130);
  ag.addColorStop(0, playerColorRGBADim);
  ag.addColorStop(1, 'transparent');
  X.fillStyle = ag; X.fillRect(0,0,W,H);

  // ‚îÄ‚îÄ WALLS ‚îÄ‚îÄ
  walls.forEach(w => {
    // Gradient fill for top wall
    const tg = X.createLinearGradient(w.x, 0, w.x+w.w, 0);
    tg.addColorStop(0, '#1a1030'); tg.addColorStop(1, '#251848');
    X.fillStyle = tg; X.fillRect(w.x, 0, w.w, w.topH);

    // Stalactite tip
    X.fillStyle = '#2e1e5a';
    X.beginPath();
    X.moveTo(w.x, w.topH);
    X.lineTo(w.x + w.w, w.topH);
    X.lineTo(w.x + w.w/2, w.topH + 18);
    X.closePath(); X.fill();

    // Edge highlight on top wall
    X.strokeStyle = 'rgba(155,93,229,0.25)'; X.lineWidth = 1.5;
    X.strokeRect(w.x, 0, w.w, w.topH);

    // Bottom wall
    const bg2 = X.createLinearGradient(w.x, H-w.botH, w.x+w.w, H);
    bg2.addColorStop(0, '#251848'); bg2.addColorStop(1, '#1a1030');
    X.fillStyle = bg2; X.fillRect(w.x, H-w.botH, w.w, w.botH);

    // Stalagmite tip
    X.fillStyle = '#2e1e5a';
    X.beginPath();
    X.moveTo(w.x, H-w.botH);
    X.lineTo(w.x + w.w, H-w.botH);
    X.lineTo(w.x + w.w/2, H-w.botH-18);
    X.closePath(); X.fill();

    X.strokeStyle = 'rgba(155,93,229,0.25)'; X.lineWidth = 1.5;
    X.strokeRect(w.x, H-w.botH, w.w, w.botH);
  });

  // ‚îÄ‚îÄ GEMS ‚îÄ‚îÄ
  gems.forEach(g => {
    if(!g.alive) return;
    const sc = 0.88 + Math.sin(g.pulse)*0.12;
    X.save(); X.translate(g.x, g.y); X.scale(sc, sc);
    // Outer glow
    const cg = X.createRadialGradient(0,0,0,0,0,g.r*2.8);
    cg.addColorStop(0,'rgba(61,184,160,0.5)'); cg.addColorStop(1,'transparent');
    X.fillStyle = cg; X.beginPath(); X.arc(0,0,g.r*2.8,0,Math.PI*2); X.fill();
    // Diamond shape
    X.fillStyle = '#3db8a0';
    X.beginPath();
    X.moveTo(0, -g.r); X.lineTo(g.r*0.7, 0); X.lineTo(0, g.r); X.lineTo(-g.r*0.7, 0);
    X.closePath(); X.fill();
    X.strokeStyle = '#a0f8e8'; X.lineWidth = 1.5; X.stroke();
    // Inner highlight
    X.fillStyle = 'rgba(255,255,255,0.3)';
    X.beginPath(); X.ellipse(-2,-2,g.r*0.3,g.r*0.2,-.5,0,Math.PI*2); X.fill();
    X.restore();
  });

  // ‚îÄ‚îÄ SHIELDS ‚îÄ‚îÄ
  shields.forEach(s => {
    if(!s.alive) return;
    s.pulse += 0.09;
    const sc = 0.85 + Math.sin(s.pulse)*0.15;
    X.save(); X.translate(s.x, s.y); X.scale(sc, sc);
    // Glow
    const sg = X.createRadialGradient(0,0,0,0,0,s.r*2.5);
    sg.addColorStop(0,'rgba(68,136,255,0.6)'); sg.addColorStop(1,'transparent');
    X.fillStyle = sg; X.beginPath(); X.arc(0,0,s.r*2.5,0,Math.PI*2); X.fill();
    // Shield icon
    X.fillStyle = '#4488ff';
    X.beginPath();
    X.moveTo(0, -s.r); X.lineTo(s.r*0.7, -s.r*0.4);
    X.lineTo(s.r*0.7, s.r*0.2); X.lineTo(0, s.r);
    X.lineTo(-s.r*0.7, s.r*0.2); X.lineTo(-s.r*0.7, -s.r*0.4);
    X.closePath(); X.fill();
    X.strokeStyle = '#aaccff'; X.lineWidth = 1.5; X.stroke();
    X.restore();
  });

  // ‚îÄ‚îÄ TRAIL ‚îÄ‚îÄ
  trail.forEach((t, i) => {
    const a = (i / trail.length) * 0.4;
    const r = (i / trail.length) * PSZ * 0.55;
    X.globalAlpha = a;
    X.fillStyle = playerColor;
    X.beginPath(); X.arc(t.x, t.y, r, 0, Math.PI*2); X.fill();
  });
  X.globalAlpha = 1;

  // ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ
  parts.forEach(p => {
    X.globalAlpha = Math.max(0, p.a);
    if(p.pop) {
      X.font = `bold ${p.sz}px Cinzel,serif`;
      X.textAlign = 'center'; X.textBaseline = 'middle';
      X.fillStyle = p.col; X.fillText(p.txt, p.x, p.y);
    } else {
      X.fillStyle = p.col; X.beginPath(); X.arc(p.x, p.y, p.r, 0, Math.PI*2); X.fill();
    }
  });
  X.globalAlpha = 1;

  // ‚îÄ‚îÄ PLAYER ‚îÄ‚îÄ
  X.save(); X.translate(PX+PSZ, py+PSZ);
  if(flipped) X.scale(1,-1);

  // Outer glow halo
  const pl = X.createRadialGradient(0,0,0,0,0,PSZ*2.2);
  pl.addColorStop(0, playerColorRGBA);
  pl.addColorStop(1, 'transparent');
  X.fillStyle = pl; X.beginPath(); X.arc(0,0,PSZ*2.2,0,Math.PI*2); X.fill();

  // Body
  const bodyColorMap = {
    '#9b5de5': flipped ? '#1a6a58' : '#3a1860',
    '#3db8a0': flipped ? '#1a5040' : '#0e3050',
    '#e8a020': flipped ? '#5a3010' : '#3a2010',
    '#ff4444': flipped ? '#6a1020' : '#3a1010',
    '#4488ff': flipped ? '#102060' : '#101048',
  };
  const bc = bodyColorMap[playerColor] || (flipped ? '#1a6a58' : '#3a1860');
  X.fillStyle = bc;
  X.beginPath(); X.roundRect(-PSZ,-PSZ,PSZ*2,PSZ*2,5); X.fill();

  // Visor / top strip
  const vc = playerColor;
  X.fillStyle = vc;
  X.beginPath(); X.roundRect(-PSZ,-PSZ,PSZ*2,PSZ*0.45,3); X.fill();

  // Eyes
  X.fillStyle='#f0e6d0';
  X.beginPath(); X.arc(-7,-4,3.5,0,Math.PI*2); X.fill();
  X.beginPath(); X.arc( 7,-4,3.5,0,Math.PI*2); X.fill();
  X.fillStyle='#1a0830';
  X.beginPath(); X.arc(-7,-4,1.8,0,Math.PI*2); X.fill();
  X.beginPath(); X.arc( 7,-4,1.8,0,Math.PI*2); X.fill();

  X.restore();

  // Shield aura on player
  if(hasShield) {
    const shieldPulse = 0.7 + 0.3 * Math.sin(tick * 0.15);
    X.globalAlpha = shieldPulse * 0.6;
    X.strokeStyle = '#4488ff';
    X.lineWidth = 3;
    X.beginPath(); X.arc(PX+PSZ, py+PSZ, PSZ*1.6, 0, Math.PI*2); X.stroke();
    X.globalAlpha = shieldPulse * 0.15;
    X.fillStyle = '#4488ff';
    X.beginPath(); X.arc(PX+PSZ, py+PSZ, PSZ*1.6, 0, Math.PI*2); X.fill();
    X.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ HUD ‚îÄ‚îÄ
  const HH = 68;
  X.fillStyle = 'rgba(4,2,12,0.92)'; X.fillRect(0,0,W,HH);
  X.strokeStyle='rgba(30,16,56,0.9)'; X.lineWidth=1.5;
  X.beginPath(); X.moveTo(0,HH); X.lineTo(W,HH); X.stroke();

  const p = 16;
  X.textBaseline='top';

  X.textAlign='left';
  X.font='bold 10px Nunito,sans-serif'; X.fillStyle='#9a8870'; X.fillText('SCORE',p,p);
  X.font='bold 26px Cinzel,serif'; X.fillStyle='#ffcc55'; X.fillText(score,p,p+13);

  X.textAlign='center';
  X.font='bold 10px Nunito,sans-serif'; X.fillStyle='#9a8870'; X.fillText('BEST',W/2,p);
  X.font='bold 20px Cinzel,serif'; X.fillStyle='#e8a020'; X.fillText(hi,W/2,p+13);

  X.textAlign='center';
  X.font='bold 10px Nunito,sans-serif'; X.fillStyle='#9a8870'; X.fillText('LEVEL',W*0.74,p);
  X.font='bold 20px Cinzel,serif'; X.fillStyle='#3db8a0'; X.fillText(level,W*0.74,p+13);

  X.textAlign='right';
  X.font='bold 10px Nunito,sans-serif'; X.fillStyle='#9a8870';
  X.fillText(hasShield ? 'üõ° SHIELD' : (flipped?'‚Üë FLIPPED':'‚Üì NORMAL'), W-p, p);
  const arrowCol = hasShield ? '#4488ff' : (flipped ? '#3db8a0' : '#9b5de5');
  X.font='bold 20px Cinzel,serif'; X.fillStyle=arrowCol;
  X.fillText(hasShield ? 'üõ°' : (flipped?'‚¨Ü':'‚¨á'), W-p, p+13);

  X.restore();
}

/* ‚îÄ‚îÄ‚îÄ SCREENS ‚îÄ‚îÄ‚îÄ */
function drawMenu() {
  const bg = X.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,'#04020c'); bg.addColorStop(1,'#080418');
  X.fillStyle=bg; X.fillRect(0,0,W,H);

  // Decorative walls top & bottom
  X.fillStyle='#1a1030'; X.fillRect(0,0,W,56); X.fillRect(0,H-56,W,56);
  X.fillStyle='#2e1e5a';
  for(let i=0;i<9;i++){
    const x=i*(W/8);
    X.beginPath(); X.moveTo(x,56); X.lineTo(x+W/16,56); X.lineTo(x+W/32,90); X.closePath(); X.fill();
    X.beginPath(); X.moveTo(x,H-56); X.lineTo(x+W/16,H-56); X.lineTo(x+W/32,H-90); X.closePath(); X.fill();
  }

  X.textAlign='center'; X.textBaseline='middle';
  X.font=`bold ${Math.min(48,W*0.1)}px Cinzel,serif`;
  X.shadowColor='#9b5de5'; X.shadowBlur=35; X.fillStyle='#e8a020';
  X.fillText('GRAVITY FLIP', W/2, H*0.38);
  X.shadowBlur=0;

  X.font=`${Math.min(15,W*0.038)}px Nunito,sans-serif`; X.fillStyle='#9a8870';
  X.fillText('Tap or press SPACE to flip gravity', W/2, H*0.49);
  X.fillText('Pass through the gaps without hitting the walls', W/2, H*0.55);
  X.fillText('üíé Collect crystals for +3 bonus points', W/2, H*0.60);
  X.fillText('üõ° Blue shields absorb one hit!', W/2, H*0.65);

  // Color picker
  X.font=`${Math.min(12,W*0.03)}px Nunito,sans-serif`; X.fillStyle='#9a8870';
  X.fillText('PLAYER COLOR', W/2, H*0.80);
  PLAYER_COLORS.forEach((col, i) => {
    const cx = W/2 + (i-2)*36, cy = H*0.87, r=12;
    X.beginPath(); X.arc(cx, cy, r, 0, Math.PI*2);
    X.fillStyle = col; X.fill();
    if(i === playerColorIdx) { X.strokeStyle='#fff'; X.lineWidth=3; X.stroke(); }
  });

  drawButton(W/2, H*0.73, '‚¨Ü‚¨á  LET\'S GO', '#9b5de5', '#3db8a0');
}

function drawGameOver() {
  // Keep the last frame visible under the overlay
  X.fillStyle='rgba(0,0,0,0.80)'; X.fillRect(0,0,W,H);
  X.textAlign='center'; X.textBaseline='middle';

  X.font=`bold ${Math.min(46,W*0.1)}px Cinzel,serif`;
  X.shadowColor='#e74c3c'; X.shadowBlur=28; X.fillStyle='#e74c3c';
  X.fillText('SMASHED!', W/2, H*0.3);
  X.shadowBlur=0;

  X.font=`bold ${Math.min(26,W*0.065)}px Nunito,sans-serif`; X.fillStyle='#f0e6d0';
  X.fillText('Score  ' + score, W/2, H*0.42);
  X.fillText('Best   ' + hi,    W/2, H*0.50);

  X.font=`${Math.min(15,W*0.038)}px Nunito,sans-serif`; X.fillStyle='#9a8870';
  const msg = score>=50?'Cave Master! üèÜ':score>=20?'Solid run! üíé':'The cave won this time...';
  X.fillText(msg, W/2, H*0.58);

  drawButton(W/2, H*0.71, '‚¨Ü‚¨á  TRY AGAIN', '#9b5de5', '#3db8a0');
}

function drawButton(cx, cy, label, c1, c2) {
  const bw=Math.min(260,W*0.65), bh=54, bx=cx-bw/2, by=cy-bh/2;
  const g=X.createLinearGradient(bx,cy,bx+bw,cy);
  g.addColorStop(0,c1); g.addColorStop(1,c2);
  X.fillStyle=g; X.beginPath(); X.roundRect(bx,by,bw,bh,bh/2); X.fill();
  X.font='bold 17px Cinzel,serif'; X.fillStyle='#f0e6d0';
  X.textAlign='center'; X.textBaseline='middle'; X.fillText(label,cx,cy);
}

/* ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ */
function gameLoop() {
  update();
  if(phase==='play') drawGame();
  if(running) raf = requestAnimationFrame(gameLoop);
}

function startGame() {
  cancelAnimationFrame(raf);
  resetGame(); phase='play'; running=true;
  sfx.play('start');
  gtag('event','game_start',{game:'Gravity Flip'});
  raf = requestAnimationFrame(gameLoop);
}

/* ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ */
document.addEventListener('keydown', e => { if(e.code==='Space'){e.preventDefault();doFlip();} });
C.addEventListener('pointerdown', e => {
  e.preventDefault();
  if(phase === 'menu') {
    // Check if click is near color picker circles
    const rect = C.getBoundingClientRect();
    const scaleX = C.width / rect.width;
    const scaleY = C.height / rect.height;
    const cx = (e.clientX - rect.left) * scaleX;
    const cy = (e.clientY - rect.top) * scaleY;
    const pickerY = H * 0.87;
    for(let i=0; i<PLAYER_COLORS.length; i++) {
      const px2 = W/2 + (i-2)*36;
      if(Math.hypot(cx - px2, cy - pickerY) < 18) {
        playerColorIdx = i;
        playerColor = PLAYER_COLORS[i];
        playerColorRGBA = PLAYER_COLORS_RGBA[i];
        playerColorRGBADim = PLAYER_COLORS_RGBA_DIM[i];
        drawMenu();
        return;
      }
    }
  }
  doFlip();
}, {passive:false});

phase='menu'; drawMenu();
</script>
</body>
</html>
