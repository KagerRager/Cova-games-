<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P1VFNJ21V0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-P1VFNJ21V0');
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Desert Chase</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a0f00;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Courier New', monospace;
  }
  canvas { display: block; cursor: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W = Math.min(window.innerWidth, 700);
let H = Math.min(window.innerHeight, 700);
canvas.width = W;
canvas.height = H;

// â”€â”€ SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const playerColor = '#cc2200';
const copColor    = '#1a1aff';
const maxSpeed    = 5;
const copBaseSpeed = 1.8;
const spawnRate   = 90;      // frames between cop spawns
const WIN_SCORE   = 30;      // survive this many seconds to win
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€ MOUSE â”€â”€
let mouse = { x: W/2, y: H/2 };
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left;
  mouse.y = e.clientY - r.top;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  mouse.x = e.touches[0].clientX - r.left;
  mouse.y = e.touches[0].clientY - r.top;
}, { passive: false });

// â”€â”€ SCENERY â”€â”€
const ROCKS = Array.from({length:35}, () => ({
  x: Math.random()*W, y: Math.random()*H,
  r: 3+Math.random()*9, shade: Math.random()
}));
const CACTI = Array.from({length:15}, () => ({
  x: Math.random()*W, y: Math.random()*H,
  h: 14+Math.random()*20
}));
const TRACKS = Array.from({length:6}, () => ({
  x: Math.random()*W, y: Math.random()*H,
  angle: Math.random()*Math.PI*2, len: 40+Math.random()*90
}));

// â”€â”€ ESCAPE ZONE â”€â”€
// The player must reach this glowing zone to win
const ZONE = {
  x: W - 80,
  y: 40,
  w: 60,
  h: 60,
  pulse: 0
};

// â”€â”€ STATE â”€â”€
let state = 'playing'; // 'playing' | 'dead' | 'win'
let score = 0, highScore = 0, frame = 0;
let dustParticles = [], explosions = [], cops = [];
let copTimer = 0;

const player = {
  x: W/2, y: H/2,
  angle: 0,
  w: 18, h: 30
};

// â”€â”€ SPAWN COP â”€â”€
function spawnCop() {
  const side = Math.floor(Math.random()*4);
  let x, y;
  if (side===0) { x=Math.random()*W; y=-40; }
  else if (side===1) { x=W+40; y=Math.random()*H; }
  else if (side===2) { x=Math.random()*W; y=H+40; }
  else { x=-40; y=Math.random()*H; }
  cops.push({
    x, y,
    vx: 0, vy: 0,          // velocity (for proper collision)
    angle: 0,
    w: 16, h: 28,
    speed: copBaseSpeed + Math.min(score*0.008, 2),
    lt: 0
  });
}

// â”€â”€ PARTICLES â”€â”€
function spawnDust(x, y, color) {
  for (let i=0; i<4; i++) {
    const a = Math.random()*Math.PI*2;
    const s = 0.5+Math.random()*2;
    dustParticles.push({
      x, y,
      vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 1, decay: 0.035+Math.random()*0.025,
      r: 2+Math.random()*4, color: color||'#c4a257'
    });
  }
}

function spawnExplosion(x, y) {
  for (let i=0; i<45; i++) {
    const a = Math.random()*Math.PI*2;
    const s = 1+Math.random()*7;
    explosions.push({
      x, y,
      vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 1, decay: 0.012+Math.random()*0.018,
      r: 4+Math.random()*12,
      color: ['#ff6600','#ff3300','#ffcc00','#ff9900','#ffffff'][Math.floor(Math.random()*5)]
    });
  }
}

// â”€â”€ COLLISION HELPERS â”€â”€
// AABB overlap check (axis-aligned boxes)
function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax - aw/2 < bx + bw/2 &&
         ax + aw/2 > bx - bw/2 &&
         ay - ah/2 < by + bh/2 &&
         ay + ah/2 > by - bh/2;
}

// Push two cops apart so they don't phase through each other
function separateCops(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx*dx + dy*dy) || 0.001;

  // Minimum separation distance (half widths + half widths)
  const minDist = (a.w + b.w) / 2;
  if (dist >= minDist) return; // already separated

  // Overlap amount
  const overlap = (minDist - dist) / 2;
  const nx = dx / dist; // normal vector
  const ny = dy / dist;

  // Push them apart equally
  a.x -= nx * overlap;
  a.y -= ny * overlap;
  b.x += nx * overlap;
  b.y += ny * overlap;

  // Exchange velocity components along collision normal (elastic bounce)
  const dvx = b.vx - a.vx;
  const dvy = b.vy - a.vy;
  const dot = dvx * nx + dvy * ny;
  if (dot < 0) { // only if approaching each other
    a.vx += dot * nx;
    a.vy += dot * ny;
    b.vx -= dot * nx;
    b.vy -= dot * ny;
  }
}

// â”€â”€ DRAW HELPERS â”€â”€
function drawCar(x, y, angle, w, h, color, isCop) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(-w/2+3, -h/2+3, w, h);

  ctx.fillStyle = color;
  ctx.fillRect(-w/2, -h/2, w, h);

  ctx.fillStyle = 'rgba(150,220,255,0.7)';
  ctx.fillRect(-w/2+3, -h/2+4, w-6, h*0.28);
  ctx.fillRect(-w/2+3, h/2-4-h*0.2, w-6, h*0.2);

  ctx.fillStyle = '#111';
  ctx.fillRect(-w/2-3, -h/2+4, 4, 8);
  ctx.fillRect(w/2-1,  -h/2+4, 4, 8);
  ctx.fillRect(-w/2-3, h/2-12, 4, 8);
  ctx.fillRect(w/2-1,  h/2-12, 4, 8);

  if (isCop) {
    ctx.fillStyle = '#fff';
    ctx.fillRect(-w/2, -3, w, 6);
    ctx.fillStyle = '#000';
    ctx.fillRect(-w/2, -1, w, 2);
  }
  ctx.restore();
}

function drawLights(x, y, angle, lt) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  const f = Math.floor(lt/7)%2;
  ctx.shadowBlur = 16;
  ctx.fillStyle = f===0 ? '#ff2222' : '#0044ff';
  ctx.shadowColor = ctx.fillStyle;
  ctx.fillRect(-6, -14, 6, 5);
  ctx.fillStyle = f===0 ? '#0044ff' : '#ff2222';
  ctx.shadowColor = ctx.fillStyle;
  ctx.fillRect(1, -14, 6, 5);
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawDesert() {
  const g = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.8);
  g.addColorStop(0, '#e8c97a');
  g.addColorStop(0.6, '#d4a84b');
  g.addColorStop(1, '#b8882a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  TRACKS.forEach(t => {
    ctx.save();
    ctx.translate(t.x,t.y); ctx.rotate(t.angle);
    ctx.strokeStyle='rgba(100,60,0,0.2)';
    ctx.lineWidth=3; ctx.setLineDash([6,8]);
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,t.len); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  });

  ROCKS.forEach(rock => {
    ctx.fillStyle=`rgba(${120+rock.shade*40},${90+rock.shade*20},50,0.7)`;
    ctx.beginPath();
    ctx.ellipse(rock.x,rock.y,rock.r*1.4,rock.r,0,0,Math.PI*2);
    ctx.fill();
  });

  CACTI.forEach(c => {
    ctx.fillStyle='#4a7c3f';
    ctx.fillRect(c.x-3, c.y-c.h, 6, c.h);
    ctx.fillRect(c.x-10, c.y-c.h*0.6, 8, 4);
    ctx.fillRect(c.x-10, c.y-c.h*0.8, 4, c.h*0.2);
    ctx.fillRect(c.x+2, c.y-c.h*0.5, 8, 4);
    ctx.fillRect(c.x+6, c.y-c.h*0.7, 4, c.h*0.2);
  });
}

// â”€â”€ ESCAPE ZONE â”€â”€
function drawEscapeZone() {
  ZONE.pulse = (ZONE.pulse + 0.05) % (Math.PI*2);
  const glow = 0.5 + 0.5*Math.sin(ZONE.pulse);

  // Outer glow ring
  ctx.strokeStyle = `rgba(0,255,120,${0.3 + glow*0.5})`;
  ctx.lineWidth = 3 + glow*4;
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#00ff88';
  ctx.strokeRect(ZONE.x, ZONE.y, ZONE.w, ZONE.h);
  ctx.shadowBlur = 0;

  // Fill
  ctx.fillStyle = `rgba(0,255,120,${0.08 + glow*0.1})`;
  ctx.fillRect(ZONE.x, ZONE.y, ZONE.w, ZONE.h);

  // Label
  ctx.fillStyle = `rgba(0,255,120,${0.7 + glow*0.3})`;
  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('ESCAPE', ZONE.x + ZONE.w/2, ZONE.y + ZONE.h/2 - 6);
  ctx.fillText('ZONE', ZONE.x + ZONE.w/2, ZONE.y + ZONE.h/2 + 8);

  // Arrow pointing to zone if player is far
  const pdx = ZONE.x + ZONE.w/2 - player.x;
  const pdy = ZONE.y + ZONE.h/2 - player.y;
  const pdist = Math.sqrt(pdx*pdx + pdy*pdy);
  if (pdist > 120) {
    const ang = Math.atan2(pdy, pdx);
    const ax = player.x + Math.cos(ang)*40;
    const ay = player.y + Math.sin(ang)*40;
    ctx.fillStyle = `rgba(0,255,120,${0.5+glow*0.4})`;
    ctx.save();
    ctx.translate(ax, ay);
    ctx.rotate(ang);
    ctx.beginPath();
    ctx.moveTo(10,0); ctx.lineTo(-6,-6); ctx.lineTo(-6,6); ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  ctx.textAlign = 'left';
}

// â”€â”€ HUD â”€â”€
function drawHUD() {
  // Score
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(8,8,160,34);
  ctx.fillStyle = '#ffdd44';
  ctx.font = 'bold 14px Courier New';
  ctx.fillText(`SCORE: ${score}`, 18, 30);

  // Cops
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(W-150,8,142,34);
  ctx.fillStyle = '#ff4444';
  ctx.textAlign = 'right';
  ctx.fillText(`COPS: ${cops.length}`, W-16, 30);
  ctx.textAlign = 'left';

  // Win progress bar
  const pct = Math.min(score / WIN_SCORE, 1);
  const bw = W - 20;
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(10, H-28, bw, 16);
  ctx.fillStyle = `rgba(0,${Math.floor(200*pct+55)},${Math.floor(120*pct)},0.85)`;
  ctx.fillRect(10, H-28, bw*pct, 16);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(10, H-28, bw, 16);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(`SURVIVE ${WIN_SCORE - score > 0 ? WIN_SCORE - score : 0}s MORE TO ESCAPE`, W/2, H-16);
  ctx.textAlign = 'left';
}

// â”€â”€ SCREENS â”€â”€
function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.fillRect(0,0,W,H);
  const pw=300,ph=240,px=W/2-pw/2,py=H/2-ph/2;
  ctx.fillStyle='#1a0800'; ctx.strokeStyle='#ff4400'; ctx.lineWidth=3;
  ctx.fillRect(px,py,pw,ph); ctx.strokeRect(px,py,pw,ph);
  ctx.fillStyle='#ff4400'; ctx.font='bold 40px Courier New';
  ctx.textAlign='center';
  ctx.fillText('BUSTED!',W/2,py+62);
  ctx.font='34px serif'; ctx.fillText('ðŸš”ðŸ’¥',W/2,py+108);
  ctx.fillStyle='#ffcc44'; ctx.font='bold 18px Courier New';
  ctx.fillText('Score: '+score,W/2,py+148);
  ctx.fillStyle='#888'; ctx.font='14px Courier New';
  ctx.fillText('Best: '+highScore,W/2,py+174);
  ctx.fillStyle='#fff'; ctx.font='13px Courier New';
  ctx.fillText('Click to try again',W/2,py+212);
  ctx.textAlign='left';
}

function drawWinScreen() {
  ctx.fillStyle = 'rgba(0,20,0,0.75)';
  ctx.fillRect(0,0,W,H);
  const pw=320,ph=260,px=W/2-pw/2,py=H/2-ph/2;
  ctx.fillStyle='#001a00'; ctx.strokeStyle='#00ff88'; ctx.lineWidth=3;
  ctx.fillRect(px,py,pw,ph); ctx.strokeRect(px,py,pw,ph);

  ctx.shadowBlur=20; ctx.shadowColor='#00ff88';
  ctx.fillStyle='#00ff88'; ctx.font='bold 38px Courier New';
  ctx.textAlign='center';
  ctx.fillText('YOU ESCAPED!',W/2,py+58);
  ctx.shadowBlur=0;

  ctx.font='34px serif'; ctx.fillText('ðŸ†ðŸš—ðŸ’¨',W/2,py+108);
  ctx.fillStyle='#ffdd44'; ctx.font='bold 17px Courier New';
  ctx.fillText('Score: '+score,W/2,py+148);
  ctx.fillStyle='#888'; ctx.font='13px Courier New';
  ctx.fillText('Best: '+highScore,W/2,py+174);
  ctx.fillStyle='#aaffcc'; ctx.font='12px Courier New';
  ctx.fillText('You outran '+cops.length+' cop cars!',W/2,py+200);
  ctx.fillStyle='#fff'; ctx.font='13px Courier New';
  ctx.fillText('Click to play again',W/2,py+232);
  ctx.textAlign='left';
}

// â”€â”€ RESTART â”€â”€
function restart() {
  player.x=W/2; player.y=H/2; player.angle=0;
  cops=[]; dustParticles=[]; explosions=[];
  score=0; frame=0; copTimer=0;
  state='playing';
  gtag('event','game_start',{game:'Desert Chase'});
}

canvas.addEventListener('click', ()=>{ if(state!=='playing') restart(); });
canvas.addEventListener('touchend', ()=>{ if(state!=='playing') restart(); });

// â”€â”€ MAIN LOOP â”€â”€
function loop() {
  requestAnimationFrame(loop);
  frame++;

  if (state === 'playing') {

    // Player follows mouse
    const dx = mouse.x - player.x;
    const dy = mouse.y - player.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist > 4) {
      player.angle = Math.atan2(dy,dx) + Math.PI/2;
      const spd = Math.min(dist*0.12, maxSpeed);
      player.x += Math.cos(Math.atan2(dy,dx))*spd;
      player.y += Math.sin(Math.atan2(dy,dx))*spd;
      if (frame%4===0) spawnDust(player.x, player.y+10);
    }
    player.x = Math.max(player.w, Math.min(W-player.w, player.x));
    player.y = Math.max(player.h, Math.min(H-player.h, player.y));

    // Spawn cops (no limit!)
    copTimer++;
    if (copTimer >= spawnRate) {
      spawnCop();
      copTimer = 0;
    }

    // Move cops
    cops.forEach(cop => {
      const ca = Math.atan2(player.y-cop.y, player.x-cop.x);
      cop.angle = ca + Math.PI/2;

      // Apply steering toward player
      const targetVx = Math.cos(ca)*cop.speed;
      const targetVy = Math.sin(ca)*cop.speed;
      cop.vx += (targetVx - cop.vx) * 0.15; // smooth steering
      cop.vy += (targetVy - cop.vy) * 0.15;
      cop.x += cop.vx;
      cop.y += cop.vy;
      cop.lt++;
      if (frame%7===0) spawnDust(cop.x, cop.y+10);
    });

    // â”€â”€ COP-COP COLLISION (separate all pairs) â”€â”€
    for (let i = 0; i < cops.length; i++) {
      for (let j = i+1; j < cops.length; j++) {
        separateCops(cops[i], cops[j]);
      }
    }

    // â”€â”€ COP-PLAYER COLLISION â”€â”€
    for (const cop of cops) {
      if (rectsOverlap(cop.x,cop.y,cop.w,cop.h, player.x,player.y,player.w,player.h)) {
        spawnExplosion(player.x, player.y);
        spawnExplosion(cop.x, cop.y);
        if (score>highScore) highScore=score;
        state='dead';
        gtag('event','game_over',{game:'Desert Chase',score:score});
        break;
      }
    }

    // â”€â”€ WIN CONDITION: reach escape zone OR survive long enough â”€â”€
    if (state === 'playing') {
      const inZone = player.x > ZONE.x && player.x < ZONE.x+ZONE.w &&
                     player.y > ZONE.y && player.y < ZONE.y+ZONE.h;
      const survived = score >= WIN_SCORE;
      if (inZone || survived) {
        if (score>highScore) highScore=score;
        state='win';
        gtag('event','game_win',{game:'Desert Chase',score:score});
      }
    }

    // Score (1 per second)
    if (frame%60===0) score++;
  }

  // Update particles
  dustParticles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vx*=0.92; p.vy*=0.92; p.life-=p.decay; });
  dustParticles = dustParticles.filter(p=>p.life>0);
  explosions.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vx*=0.94; p.vy*=0.94; p.life-=p.decay; });
  explosions = explosions.filter(p=>p.life>0);

  // â”€â”€ DRAW â”€â”€
  drawDesert();
  drawEscapeZone();

  // Dust
  dustParticles.forEach(p=>{
    ctx.globalAlpha=p.life*0.4;
    ctx.fillStyle=p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha=1;

  // Cars
  if (state==='playing' || state==='win') {
    cops.forEach(cop=>{
      drawCar(cop.x,cop.y,cop.angle,cop.w,cop.h,copColor,true);
      drawLights(cop.x,cop.y,cop.angle,cop.lt);
    });
    drawCar(player.x,player.y,player.angle,player.w,player.h,playerColor,false);
  }

  // Explosions
  explosions.forEach(p=>{
    ctx.globalAlpha=p.life*0.9;
    ctx.fillStyle=p.color;
    ctx.shadowBlur=14; ctx.shadowColor=p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha=1; ctx.shadowBlur=0;

  if (state==='playing') drawHUD();
  if (state==='dead') drawGameOver();
  if (state==='win') { drawHUD(); drawWinScreen(); }

  // Intro tip
  if (state==='playing' && frame<200) {
    ctx.globalAlpha=Math.min(1,(200-frame)/60);
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(W/2-160, H/2+60, 320, 46);
    ctx.fillStyle='#fff';
    ctx.font='13px Courier New';
    ctx.textAlign='center';
    ctx.fillText('Move your mouse to drive!', W/2, H/2+80);
    ctx.fillStyle='#aaffcc';
    ctx.font='11px Courier New';
    ctx.fillText('Reach the ESCAPE ZONE â†— or survive '+WIN_SCORE+'s', W/2, H/2+98);
    ctx.textAlign='left';
    ctx.globalAlpha=1;
  }
}

loop();
</script>
</body>
</html>
