<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake – Cova Games</title>
  <link href="https://fonts.googleapis.com/css2?family=Boogaloo&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet" />
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-P1VFNJ21V0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P1VFNJ21V0');
  </script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0f0a1e;
      color: #fff;
      font-family: 'Nunito', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* ── Header ── */
    header {
      width: 100%;
      padding: 14px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid #2e1f5e;
      background: #1a1133;
    }
    header a {
      color: #ffe94d;
      text-decoration: none;
      font-family: 'Nunito', sans-serif;
      font-weight: 700;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: opacity 0.2s;
    }
    header a:hover { opacity: 0.75; }
    header h1 {
      font-family: 'Boogaloo', cursive;
      font-size: 1.6rem;
      background: linear-gradient(90deg, #ffe94d, #ff6b2b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* ── Main layout ── */
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px 16px 32px;
      gap: 20px;
    }

    /* ── Score bar ── */
    #score-bar {
      display: flex;
      gap: 32px;
      font-family: 'Nunito', sans-serif;
      font-weight: 700;
      font-size: 1.05rem;
    }
    .score-label { color: #9b5de5; }
    .score-value { color: #ffe94d; }

    /* ── Canvas wrapper ── */
    #canvas-wrap {
      position: relative;
      border: 2px solid #2e1f5e;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 40px #9b5de540;
    }

    canvas {
      display: block;
      background: #0f0a1e;
    }

    /* ── Overlay screens ── */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
      background: rgba(15, 10, 30, 0.88);
      backdrop-filter: blur(4px);
    }
    .overlay.hidden { display: none; }

    .overlay h2 {
      font-family: 'Boogaloo', cursive;
      font-size: 2.4rem;
      background: linear-gradient(90deg, #3dff8a, #00e5ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .overlay h2.gameover-title {
      background: linear-gradient(90deg, #ff3d8a, #ff6b2b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay p {
      font-size: 0.95rem;
      color: #c0b0e0;
      text-align: center;
      max-width: 280px;
      line-height: 1.5;
    }
    .overlay .stat {
      font-size: 1.05rem;
      color: #fff;
      font-weight: 700;
    }
    .overlay .stat span { color: #ffe94d; }

    .btn {
      margin-top: 6px;
      padding: 12px 32px;
      border: none;
      border-radius: 50px;
      font-family: 'Boogaloo', cursive;
      font-size: 1.3rem;
      cursor: pointer;
      background: linear-gradient(135deg, #9b5de5, #ff3d8a);
      color: #fff;
      letter-spacing: 0.5px;
      transition: transform 0.15s, box-shadow 0.15s;
      box-shadow: 0 4px 20px #ff3d8a50;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 28px #ff3d8a70; }
    .btn:active { transform: translateY(0); }

    .key-hint {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    kbd {
      background: #2e1f5e;
      border: 1px solid #9b5de5;
      border-radius: 5px;
      padding: 2px 8px;
      font-family: 'Nunito', sans-serif;
      font-size: 0.8rem;
      color: #ffe94d;
    }

    /* ── Footer ── */
    footer {
      padding: 12px;
      color: #4a3870;
      font-size: 0.78rem;
    }
  </style>
</head>
<body>

<header>
  <a href="index.html">&#8592; Back</a>
  <h1>Cova Games</h1>
</header>

<main>
  <div id="score-bar">
    <div><span class="score-label">SCORE </span><span class="score-value" id="score-display">0</span></div>
    <div><span class="score-label">BEST </span><span class="score-value" id="hi-display">0</span></div>
  </div>

  <div id="canvas-wrap">
    <canvas id="game-canvas" width="400" height="400"></canvas>

    <!-- Start screen -->
    <div class="overlay" id="start-screen">
      <h2>SNAKE</h2>
      <p>Eat the glowing food to grow. Don't hit the walls or yourself!</p>
      <div class="key-hint">
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
        <span style="color:#9b5de5;align-self:center">or</span>
        <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd>
      </div>
      <p style="font-size:0.82rem;color:#7060a0">Swipe on mobile</p>
      <button class="btn" id="start-btn">Play</button>
    </div>

    <!-- Game-over screen -->
    <div class="overlay hidden" id="gameover-screen">
      <h2 class="gameover-title">GAME OVER</h2>
      <p class="stat">Score: <span id="final-score">0</span></p>
      <p class="stat">Best: <span id="final-hi">0</span></p>
      <button class="btn" id="restart-btn">Play Again</button>
    </div>
  </div>
</main>

<footer>&copy; 2025 Cova Games</footer>

<script>
(function () {
  'use strict';

  /* ── Constants ── */
  const COLS = 20, ROWS = 20, CELL = 20;
  const W = COLS * CELL, H = ROWS * CELL;
  const LS_KEY = 'snake_hi';
  const BASE_INTERVAL = 150; // ms

  /* ── State ── */
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const startScreen = document.getElementById('start-screen');
  const gameoverScreen = document.getElementById('gameover-screen');
  const scoreDisplay = document.getElementById('score-display');
  const hiDisplay = document.getElementById('hi-display');
  const finalScore = document.getElementById('final-score');
  const finalHi = document.getElementById('final-hi');

  let snake, dir, nextDir, food, score, hiScore, gameState, lastTime, elapsed, interval;
  let touchStartX, touchStartY;

  hiScore = parseInt(localStorage.getItem(LS_KEY) || '0', 10);
  hiDisplay.textContent = hiScore;

  /* ── Init / Reset ── */
  function initGame() {
    snake = [
      { x: 6, y: 10 },
      { x: 5, y: 10 },
      { x: 4, y: 10 }
    ];
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };
    score = 0;
    interval = BASE_INTERVAL;
    elapsed = 0;
    spawnFood();
    scoreDisplay.textContent = '0';
  }

  function spawnFood() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    food = pos;
  }

  /* ── Game loop ── */
  function loop(ts) {
    if (gameState !== 'playing') return;
    requestAnimationFrame(loop);

    const dt = ts - (lastTime || ts);
    lastTime = ts;
    elapsed += dt;

    if (elapsed >= interval) {
      elapsed -= interval;
      update();
    }

    draw();
  }

  function update() {
    dir = { ...nextDir };
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // Wall collision
    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) { endGame(); return; }
    // Self collision
    if (snake.some(s => s.x === head.x && s.y === head.y)) { endGame(); return; }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score += 10;
      scoreDisplay.textContent = score;
      // Speed up: reduce interval slightly, min 60 ms
      interval = Math.max(60, BASE_INTERVAL - Math.floor(score / 30) * 10);
      spawnFood();
    } else {
      snake.pop();
    }
  }

  /* ── Drawing ── */
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // Grid dots
    ctx.fillStyle = '#1a1133';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#2e1f5e';
    for (let c = 0; c < COLS; c++) {
      for (let r = 0; r < ROWS; r++) {
        ctx.fillRect(c * CELL + 9, r * CELL + 9, 2, 2);
      }
    }

    // Food – glowing yellow circle
    const fx = food.x * CELL + CELL / 2;
    const fy = food.y * CELL + CELL / 2;
    const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 200);
    const glowSize = 6 + pulse * 4;
    const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, glowSize + 4);
    grad.addColorStop(0, '#ffe94d');
    grad.addColorStop(0.5, '#ff6b2b88');
    grad.addColorStop(1, 'transparent');
    ctx.save();
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#ffe94d';
    ctx.beginPath();
    ctx.arc(fx, fy, glowSize / 2 + 3, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(fx, fy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#ffe94d';
    ctx.fill();
    ctx.restore();

    // Snake body
    for (let i = snake.length - 1; i >= 0; i--) {
      const s = snake[i];
      const x = s.x * CELL, y = s.y * CELL;
      const isHead = i === 0;
      const t = i / (snake.length - 1 || 1);

      if (isHead) {
        ctx.save();
        ctx.shadowBlur = 14;
        ctx.shadowColor = '#3dff8a';
        ctx.fillStyle = '#1a8a50';
        roundRect(ctx, x + 1, y + 1, CELL - 2, CELL - 2, 5);
        ctx.fill();
        ctx.restore();

        // Eyes
        const eyeOffsets = getEyeOffsets();
        ctx.fillStyle = '#0f0a1e';
        ctx.beginPath();
        ctx.arc(x + eyeOffsets[0].x, y + eyeOffsets[0].y, 2.5, 0, Math.PI * 2);
        ctx.arc(x + eyeOffsets[1].x, y + eyeOffsets[1].y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffe94d';
        ctx.beginPath();
        ctx.arc(x + eyeOffsets[0].x + 0.5, y + eyeOffsets[0].y - 0.5, 1, 0, Math.PI * 2);
        ctx.arc(x + eyeOffsets[1].x + 0.5, y + eyeOffsets[1].y - 0.5, 1, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const g = Math.floor(220 - t * 100);
        ctx.fillStyle = `rgb(10, ${g}, 80)`;
        ctx.save();
        ctx.shadowBlur = 6;
        ctx.shadowColor = '#3dff8a50';
        roundRect(ctx, x + 2, y + 2, CELL - 4, CELL - 4, 4);
        ctx.fill();
        ctx.restore();
      }
    }

    // Score on canvas (small, top-right)
    ctx.fillStyle = '#ffe94d88';
    ctx.font = 'bold 12px Nunito, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(score, W - 8, 18);
    ctx.textAlign = 'left';
  }

  function getEyeOffsets() {
    const d = dir;
    if (d.x === 1)  return [{ x: 14, y: 5  }, { x: 14, y: 15 }];
    if (d.x === -1) return [{ x: 6,  y: 5  }, { x: 6,  y: 15 }];
    if (d.y === -1) return [{ x: 5,  y: 6  }, { x: 15, y: 6  }];
    return                  [{ x: 5,  y: 14 }, { x: 15, y: 14 }];
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  /* ── Game state transitions ── */
  function startGame() {
    gameState = 'playing';
    startScreen.classList.add('hidden');
    gameoverScreen.classList.add('hidden');
    initGame();
    lastTime = null;
    elapsed = 0;
    gtag('event', 'game_start', { game: 'Snake' });
    requestAnimationFrame(loop);
  }

  function endGame() {
    gameState = 'over';
    if (score > hiScore) {
      hiScore = score;
      localStorage.setItem(LS_KEY, hiScore);
      hiDisplay.textContent = hiScore;
    }
    finalScore.textContent = score;
    finalHi.textContent = hiScore;
    gameoverScreen.classList.remove('hidden');
    gtag('event', 'game_over', { game: 'Snake', score: score });
  }

  /* ── Input ── */
  const dirMap = {
    ArrowUp:    { x: 0,  y: -1 }, w: { x: 0,  y: -1 },
    ArrowDown:  { x: 0,  y:  1 }, s: { x: 0,  y:  1 },
    ArrowLeft:  { x: -1, y:  0 }, a: { x: -1, y:  0 },
    ArrowRight: { x: 1,  y:  0 }, d: { x: 1,  y:  0 },
  };

  document.addEventListener('keydown', e => {
    const key = e.key;
    const mapped = dirMap[key] || dirMap[key.toLowerCase()];
    if (mapped) {
      e.preventDefault();
      if (gameState === 'playing') {
        // Prevent reversing
        if (mapped.x !== -dir.x || mapped.y !== -dir.y) {
          nextDir = mapped;
        }
      }
    }
    if ((key === ' ' || key === 'Enter') && gameState !== 'playing') {
      startGame();
    }
  });

  // Touch swipe
  canvas.addEventListener('touchstart', e => {
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
  }, { passive: true });

  canvas.addEventListener('touchend', e => {
    if (gameState !== 'playing') return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
    let mapped;
    if (Math.abs(dx) > Math.abs(dy)) {
      mapped = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
    } else {
      mapped = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
    }
    if (mapped.x !== -dir.x || mapped.y !== -dir.y) nextDir = mapped;
  }, { passive: true });

  /* ── Buttons ── */
  document.getElementById('start-btn').addEventListener('click', startGame);
  document.getElementById('restart-btn').addEventListener('click', startGame);

  /* ── Initial render ── */
  gameState = 'start';
  initGame();
  draw();
})();
</script>
</body>
</html>
